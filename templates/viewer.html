<!DOCTYPE html>
<html>
<head>
    <title>Viewer - {{ folder_name }}</title>
    <style>
        /* Your existing styles */
        body { font-family: Arial, sans-serif; }
        #carousel-container { text-align: center; margin-top: 20px; }
        .carousel-image { max-width: 100%; height: auto; margin: 10px; }
        #metadata { margin-top: 20px; }
        #navigation { margin-top: 20px; text-align: center; }
        button, input[type="range"] { margin: 5px; }
        #folder-link { margin-bottom: 20px; display: block; }
        #slider-container { text-align: center; margin-top: 20px; }
        table { margin: 0 auto; border-collapse: collapse; }
        td, th { padding: 5px; border: 1px solid #ccc; }
        #auto-inference-container { text-align: center; margin-top: 10px; }
        .frame-group { display: flex; justify-content: center; flex-wrap: wrap; }
        .image-container { display: flex; flex-direction: column; align-items: center; margin: 5px; }
        .frame-index { margin-top: 5px; font-size: 14px; color: #555; }
    </style>
</head>
<body>
    <a id="folder-link" href="/">&#8592; Back to Folders</a>
    <h1>Viewing Folder: {{ folder_name }}</h1>
    
    <div id="carousel-container">
        <div class="frame-group" id="frame-group">
            <!-- Dynamically populated with multiple images -->
        </div>
    </div>
    
    <div id="metadata">
        <p>Frame: <span id="frame-number"></span> / <span id="total-frames"></span></p>
        <p>Input (Metadata): <span id="input-data">None</span></p>
        <p>Input (Cache): <span id="input-data-cache">None</span></p>
        <p>Model Prediction: <span id="model-prediction">None</span></p>
        <p>Reward (Metadata): <span id="reward-data">None</span></p>
        <p>Punishment (Metadata): <span id="punishment-data">None</span></p>
        <p>Net Reward (Cache): <span id="net-reward-cache">None</span></p>
        <p>Next Reward: <span id="next-reward-data">None</span></p>
        <p>Next Punishment: <span id="next-punishment-data">None</span></p>
        <p>Winner: <span id="winner-status">Undetermined</span></p>
    </div>
    
    <div id="slider-container">
        <input type="range" id="frame-slider" min="0" max="0" value="0" style="width: 80%;">
    </div>
    
    <div id="navigation">
        <button id="prev-button">Previous Frame</button>
        <button id="next-button">Next Frame</button>
        <button id="inference-button">Run Inference</button> <!-- Button to trigger inference -->
        <button id="swap-player-button">Swap Player</button>
    </div>

    <!-- Auto-inference checkbox container -->
    <div id="auto-inference-container">
        <label><input type="checkbox" id="auto-inference-checkbox"> Auto-Inference</label>
    </div>

    <script>
        // Define bit positions for each key
        const KEY_BIT_POSITIONS = {
            'A': 8,
            'DOWN': 7,
            'UP': 6,
            'LEFT': 5,
            'RIGHT': 4,
            'X': 1,
            'Z': 0,
            'S': 9
        };
        
        // Function to convert binary string to button names
        function binaryToButtons(binaryStr) {
            let buttons = [];
            for (const [button, pos] of Object.entries(KEY_BIT_POSITIONS)) {
                // Ensure the binary string is long enough
                if (binaryStr.length > pos) {
                    // Bit positions are from right (LSB) to left (MSB)
                    const bit = binaryStr.charAt(binaryStr.length - pos - 1);
                    if (bit === '1') {
                        buttons.push(button);
                    }
                }
            }
            return buttons;
        }
        
        var folderName = "{{ folder_name }}";
        var currentFrame = 0;
        var totalFrames = 0;
        var autoInference = false; // Flag for auto-inference
        var imageMemory = JSON.parse('{{ image_memory | tojson | default(1) }}'); // Correctly pass image_memory from backend

        console.log("Image Memory:", imageMemory); // Debugging

        function updateSliderMax(maxValue) {
            const slider = document.getElementById('frame-slider');
            slider.max = maxValue - 1;
            slider.disabled = false;  // Enable the slider once the max value is set
        }
        // Swap Player button event listener
        document.getElementById('swap-player-button').addEventListener('click', function() {
            if (confirm('Are you sure you want to swap the player data? ')) {
                swapPlayer();
            }
        });

        function swapPlayer() {
            fetch(`/folder/${folderName}/swap_player`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
            })
            .then(response => {
                if (!response.ok) {
                    return response.json().then(errData => { throw errData; });
                }
                return response.json();
            })
            .then(data => {
                alert(data.message);
                // Reload the current frame to reflect changes
                loadFrame(currentFrame);
            })
            .catch(error => {
                console.error('Error swapping player:', error);
                alert('Error swapping player: ' + (error.error || 'Unknown error'));
            });
        }


        function loadFrame(frameIndex) {
            fetch(`/folder/${folderName}/frame/${frameIndex}`)
                .then(response => response.json())
                .then(data => {
                    console.log("Loaded Frame Data:", data); // Debugging
                    currentFrame = data.current_frame;
                    totalFrames = data.total_frames;

                    // Update frame data
                    document.getElementById('frame-number').textContent = currentFrame + 1;
                    document.getElementById('total-frames').textContent = totalFrames;
                    
                    // Convert binary strings to button names
                    const inputButtons = data.input ? binaryToButtons(data.input) : [];
                    const inputCacheButtons = data.pt_input_tensor ? binaryToButtons(data.pt_input_tensor.join('')) : [];
                    const modelPredictionButtons = data.model_prediction ? binaryToButtons(data.model_prediction) : [];

                    // Join button names with commas for display
                    document.getElementById('input-data').textContent = inputButtons.length > 0 ? inputButtons.join(', ') : 'None';
                    document.getElementById('input-data-cache').textContent = inputCacheButtons.length > 0 ? inputCacheButtons.join(', ') : 'None';
                    document.getElementById('model-prediction').textContent = modelPredictionButtons.length > 0 ? modelPredictionButtons.join(', ') : 'None';

                    document.getElementById('reward-data').textContent = data.reward !== null ? data.reward : 'None';
                    document.getElementById('punishment-data').textContent = data.punishment !== null ? data.punishment : 'None';

                    // Update cache data
                    document.getElementById('net-reward-cache').textContent = data.pt_net_reward !== null ? data.pt_net_reward : 'None';
                    
                    // Update next reward data
                    if (data.next_reward) {
                        document.getElementById('next-reward-data').textContent =
                            'Reward ' + data.next_reward.value + ', ' + data.next_reward.frames_ahead + ' frames ahead';
                    } else {
                        document.getElementById('next-reward-data').textContent = 'None';
                    }

                    // Update next punishment data
                    if (data.next_punishment) {
                        document.getElementById('next-punishment-data').textContent =
                            'Punishment ' + data.next_punishment.value + ', ' + data.next_punishment.frames_ahead + ' frames ahead';
                    } else {
                        document.getElementById('next-punishment-data').textContent = 'None';
                    }

                    // Update winner status
                    const winnerText = data.winner === true ? "Yes" : data.winner === false ? "No" : "Undetermined";
                    document.getElementById('winner-status').textContent = winnerText;

                    // Update images
                    const frameGroup = document.getElementById('frame-group');
                    frameGroup.innerHTML = ''; // Clear existing images

                    // Load the sequence of images based on imageMemory
                    for (let i = 0; i < imageMemory; i++) {
                        // Calculate the corresponding frame index for each image in the imageMemory
                        const imgFrameIndex = frameIndex - (imageMemory - 1) + i;

                        // Ensure imgFrameIndex stays within valid bounds
                        const adjustedIndex = Math.max(0, Math.min(imgFrameIndex, data.frames.length - 1));

                        // Use adjustedIndex to access data.frames safely
                        const imgSrc = `../training_data/${folderName}/${data.frames[adjustedIndex].image_path}`;
                        console.log("Image Source:", imgSrc); // Debugging - check the image path

                        // Create a container for each image and its frame index
                        const imgContainer = document.createElement('div');
                        imgContainer.className = 'image-container';

                        const img = document.createElement('img');
                        img.src = imgSrc;
                        img.alt = `Frame ${adjustedIndex + 1}`;
                        img.className = 'carousel-image';
                        imgContainer.appendChild(img);

                        const caption = document.createElement('div');
                        caption.className = 'frame-index';
                        caption.textContent = `Frame ${frameIndex - adjustedIndex + 1}`;
                        imgContainer.appendChild(caption);

                        frameGroup.appendChild(imgContainer);
                    }

                    // Update slider
                    document.getElementById('frame-slider').value = currentFrame;

                    // Clear model prediction until inference is run
                    document.getElementById('model-prediction').textContent = 'None';
                    
                    // Set the slider max value if it's the first load
                    if (totalFrames > 0 && document.getElementById('frame-slider').max == "0") {
                        updateSliderMax(totalFrames);
                    }

                    // Automatically run inference if auto-inference is enabled
                    if (autoInference) {
                        runInference(currentFrame);
                    }
                })
                .catch(error => {
                    console.error('Error loading frame data:', error);
                });
        }

        // Button event listeners
        document.getElementById('prev-button').addEventListener('click', function() {
            if (currentFrame > 0) {
                loadFrame(currentFrame - 1);
            }
        });
    
        document.getElementById('next-button').addEventListener('click', function() {
            if (currentFrame < totalFrames - 1) {
                loadFrame(currentFrame + 1);
            }
        });

        // Inference button event listener
        document.getElementById('inference-button').addEventListener('click', function() {
            runInference(currentFrame);
        });

        // Auto-inference checkbox event listener
        document.getElementById('auto-inference-checkbox').addEventListener('change', function() {
            autoInference = this.checked;
        });
    
        // Slider change event
        document.getElementById('frame-slider').addEventListener('input', function() {
            loadFrame(parseInt(this.value));
        });
    
        // Keyboard navigation
        document.addEventListener('keydown', function(event) {
            if (event.key === 'ArrowLeft') {
                if (currentFrame > 0) {
                    loadFrame(currentFrame - 1);
                }
            } else if (event.key === 'ArrowRight') {
                if (currentFrame < totalFrames - 1) {
                    loadFrame(currentFrame + 1);
                }
            }
        });

        // Function to run inference when button is clicked
        function runInference(frameIndex) {
            fetch(`/folder/${folderName}/frame/${frameIndex}/inference`)
                .then(response => response.json())
                .then(data => {
                    // Convert model prediction binary to buttons
                    const modelPredictionButtons = data.model_prediction ? binaryToButtons(data.model_prediction) : [];
                    document.getElementById('model-prediction').textContent = modelPredictionButtons.length > 0 ? modelPredictionButtons.join(', ') : 'None';
                })
                .catch(error => {
                    console.error('Error running inference:', error);
                });
        }

        // Initial load
        loadFrame(0);
    </script>
    
</body>
</html>
